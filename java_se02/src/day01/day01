设计模式(Design Pattern)
是一套被反复使用,多数人知晓的,经过分类的,代码设计
经验的总结.
设计模式的使用目的就是:为了代码的可重用性,让代码
更容易被他人理解,保证代码的可靠性,设计模式使代码
的编写真正的工程化,设计模式是软件工程的基石脉络
如同大厦的结构一般,

设计模式:23种设计模式
创建型模式:单例模式,工厂模式等
结构型模式:装饰模式,代理模式等
行为型模式:模板模式,迭代器模式

单例模式:
	单例模式是Java中最简单的设计模式之一,这种类型的设计模式
	属于创建型模式,它提供了一种创建对象的最佳方式,保证一个类
	仅有一个实例,并提供一个访问它的全局访问点(公共方法访问仅有
	的一个实例).
模板模式:
定义一个操作中的算法过程骨架,而将一些步骤延迟到子类中去实现
Java中的异常处理机制
Java中异常结构定义的父类为Throwable,其派生出两个子类别:
Error:用于表示JRE的错误,该类问题是无法通过程序来解决的
		OutOfMemoryError:堆内存溢出
		StackOverflowError:栈内存溢出

Exception:表示程序级别的异常,该类问题是可以通过程序来解决的

注意:
1.异常是行为,方法,过程的意外结果
2.一个方法如果抛出了异常,这个方法就必须声明异常的抛出.
3.异常的声明:在方法上声明方法的意外结果
4.异常类一般都继承自Exception
5.调用抛出异常的方法,必须要处理异常,有两种方案:
1)使用try-catch-finally捕获异常,解决异常
2)使用throws关键字声明异常的抛出
6.如果出现了异常,异常以后的代码不会再执行(除了finally中的代码)

java异常捕获机制的语法:
try{//try块

}catch(XXXException e){//catch块
解决异常的代码片段(catch块跟在try块之后,用于捕获并解决异常
,catch块可以出现多次)
}catch(){

}finally{//finally块
	不管是否出现异常,总会被执行的代码块(通常使用finally块作为
	程序的收尾工作,finally块并不是必须的)
}

throw关键字:用于主动抛出异常
通常以下两种情况会主动的跑出异常
1.当前语句片段出现了一个不满足业务逻辑情况的异常
我们需要主动的抛出异常
2.当前代码片段出现了一个异常,但是该异常的处理不应该
由当前代码片段来负责时,我们需要主动的抛出异常

throws关键字:
声明方法时联通声明方法可能抛出的异常种类,以通知调用者在调用该方法时
应当捕获这些异常

java中将异常分为检查时异常和非检查时异常:
非检查时异常:RuntimeException及其子类
当程序中抛出了(throw)一个RuntimeException及其子类时,
编译器会在编译时不检查该类异常是否被处理

检查时异常:除了RuntimeException及其子类
当程序中抛出了一个检查时异常,编译器编译时会去检查该类
异常是否有处理代码,如果没有则编译不通过

RuntimeException的子类:
NullPointerException
StringIndexOutOfBoundsException
ArrayIndexOutOfBoundsException
ClassCastException
NumberFormatException
